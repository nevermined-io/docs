"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4687],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=l(n),h=r,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||a;return n?i.createElement(m,s(s({ref:t},d),{},{components:n})):i.createElement(m,s({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<a;l++)s[l]=n[l];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},48999:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var i=n(87462),r=(n(67294),n(3905));const a={sidebar_position:3},s="Solution Architecture",o={unversionedId:"architecture/components/proxy/architecture",id:"architecture/components/proxy/architecture",title:"Solution Architecture",description:"This page describes how the tokenization of web services via Nevermined NFTs can be implemented.",source:"@site/docs/architecture/components/proxy/architecture.md",sourceDirName:"architecture/components/proxy",slug:"/architecture/components/proxy/architecture",permalink:"/docs/architecture/components/proxy/architecture",draft:!1,editUrl:"https://github.com/nevermined-io/docs/tree/main/docs/architecture/components/proxy/architecture.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/docs/architecture/components/proxy/getting-started"},next:{title:"User Flows",permalink:"/docs/architecture/components/proxy/user-flows"}},c={},l=[{value:"Nevermined Assets",id:"nevermined-assets",level:2},{value:"Subscription",id:"subscription",level:3},{value:"Web Service",id:"web-service",level:3},{value:"NFT Access Control",id:"nft-access-control",level:2},{value:"Access Control to web services via Nevermined Proxy",id:"access-control-to-web-services-via-nevermined-proxy",level:2},{value:"Securing web services",id:"securing-web-services",level:2}],d={toc:l};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,i.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"solution-architecture"},"Solution Architecture"),(0,r.kt)("p",null,"This page describes how the tokenization of web services via Nevermined NFTs can be implemented."),(0,r.kt)("p",null,"This architecture is defined to implement the ",(0,r.kt)("a",{parentName:"p",href:"/docs/architecture/components/proxy/user-flows"},"use case and flows described in the documentation"),"."),(0,r.kt)("h2",{id:"nevermined-assets"},"Nevermined Assets"),(0,r.kt)("p",null,"In Nevermined all the assets registered in the network are composed by some off-chain metadata describing the asset and some on-chain registration.\nTo implement the tokenization via NFTs of web services it's necessary to manage 2 different kind of assets into Nevermined:"),(0,r.kt)("h3",{id:"subscription"},"Subscription"),(0,r.kt)("p",null,"The subscription is an asset describing a susbcription that can be purchased/owned by a user. This subscription is backed up by a NFT contract (in the current implementation based on the ERC-721). A Nevermined subscription typically is an asset that can be purchased by a user for some price (or for free) and when that is done a NFT ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenId")," is minted and owned by the user purchasing that subscription. Because that user owns and can demonstrate that owns that ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenId")," some off-chain or on-chain components can provide access to exclusive resources to that user."),(0,r.kt)("p",null,"In Nevermined a NFT Subscription is described by some information:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Metadata of the subscription describing it (title, price, duration, to what gives access, tags, etc). That helps to that subscription to be discovered and facilitate a purchase decision by the client."),(0,r.kt)("li",{parentName:"ul"},"A ERC-721 NFT Smart Contract that list all the holders of tokens for the subscription. The NFT Smart Contract is owned by the user deploying the NFT subscription.")),(0,r.kt)("p",null,"When a Nevermined Subscription is registered into the system by a Subscription Publisher, the following information needs to be registered into the system:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The Metadata describing the subscription will be stored off-chain in a Marketplace API (can be stored into IPFS too). Beyond the information describing the subscription the metadata must include one service describing the conditions to purchase the subscription (aka ",(0,r.kt)("inlineCode",{parentName:"li"},"nft-sales"),")"),(0,r.kt)("li",{parentName:"ul"},"The unique identifier of the subscription (Subscription DID) and the link to the Metadata will be registered into the ",(0,r.kt)("inlineCode",{parentName:"li"},"DIDRegistry")," Smart Contract"),(0,r.kt)("li",{parentName:"ul"},"The Subscription NFT (ERC-721) Smart Contract")),(0,r.kt)("p",null,"When a user discovers an interesting subscription (typically via Marketplace or similar application), that user can purchase a token of that Subscription NFT directly interacting with the Smart Contract."),(0,r.kt)("h3",{id:"web-service"},"Web Service"),(0,r.kt)("p",null,"The service requires an asset describing the web service provided to a user. The service is described in the asset metadata including:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Service description"),(0,r.kt)("li",{parentName:"ul"},"Endpoints"),(0,r.kt)("li",{parentName:"ul"},"Service authentication (needs to be ",(0,r.kt)("a",{parentName:"li",href:"https://docs.nevermined.io/docs/architecture/specs/Spec-METADATA#file-attributes"},"added into the ",(0,r.kt)("inlineCode",{parentName:"a"},"files")," section to be encrypted"),")")),(0,r.kt)("p",null,"When a Nevermined Service is registered into the system by a Publisher, the following information needs to be registered into the system:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The Metadata describing the service will be stored off-chain in a Marketplace API (can be stored into IPFS too). Because the service can not be purchased directly and only can be accessed by the holders of a different asset (the NFT susbcription) the metadata of this service only will include an access service (",(0,r.kt)("inlineCode",{parentName:"li"},"nft-access"),")."),(0,r.kt)("li",{parentName:"ul"},"The unique identifier of the service (Subscription DID) and the link to the Metadata will be registered into the ",(0,r.kt)("inlineCode",{parentName:"li"},"DIDRegistry")," Smart Contract")),(0,r.kt)("h2",{id:"nft-access-control"},"NFT Access Control"),(0,r.kt)("p",null,"When a user holds a token granting access to a service somehow this user should be able to demonstrate that. That action must happen in such a way is compatible with existing software interacting with HTTP web services. That limits the requirement of modifying client application to do Nevermined bespoke integrations, facilitating the adoption of the solution."),(0,r.kt)("p",null,"The NFT access control is designed around 2 standards: HTTP Proxies and Json Web Tokens (JWT):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Every relevant HTTP client supports the configuration of proxies that give access to HTTP resources. Tradionaly HTTP proxies have been used to provide external access from a closed network or more recently to expose and centralize web services in the shape of API gateways."),(0,r.kt)("li",{parentName:"ul"},"JSON Web Tokens (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON. JWT can be serialized and added as HTTP headers to authenticate and authorize users and the access to resources.")),(0,r.kt)("p",null,"Having into account these 2 concepts, from Nevermined we can provide a way to gate-keep the access to services to NFT holders via a bespoke HTTP proxy function. This proxy module needs to manage a JWT message including the following attributes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Subscription DID"),(0,r.kt)("li",{parentName:"ul"},"Service DID"),(0,r.kt)("li",{parentName:"ul"},"Client public address"),(0,r.kt)("li",{parentName:"ul"},"Endpoints"),(0,r.kt)("li",{parentName:"ul"},"Headers/Authentication required by the webservice")),(0,r.kt)("p",null,"The authentication of the user can be implemented via the validation of the signature of the JWT. Having the public address of the client, the proxy can check if that address is a valid subscriber of the service via balance request to the NFT (ERC-721) Subscription Smart Contract."),(0,r.kt)("p",null,"If the client is NOT a subscriptor the proxy will return a HTTP 401 Unauthorized error message.\nIf the client is a subscriptor the proxy will parse the service description and check if the resource requested is included as part of the service. If it's the proxy will send the request to the external web service and return the response."),(0,r.kt)("h2",{id:"access-control-to-web-services-via-nevermined-proxy"},"Access Control to web services via Nevermined Proxy"),(0,r.kt)("p",null,"The Nevermined Proxy validates that incoming requests are authenticated via OAuth 2.0 validation based on JSON Web Token (JWT) as defined by RFC 7519."),(0,r.kt)("p",null,"After authentication, a client presents its access token with each HTTP request to gain access to protected resources. Validation of the access token is required to ensure that it was  issued by a trusted identity provider (IdP) and that it has not expired. Because IdPs cryptographically sign the JWTs they issue, JWTs can be validated \u201coffline\u201d without a runtime dependency on the IdP. Typically, a JWT also includes an expiry date which can also be checked."),(0,r.kt)("p",null,"The standard method for validating access tokens with an IdP is called token introspection. RFC 7662, OAuth 2.0 Token Introspection, is now a widely supported standard that describes a JSON/REST interface that a Relying Party uses to present a token to the IdP, and describes the structure of the response. It is supported by many of the leading IdP vendors and cloud providers."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"NGINX Integration",src:n(56321).Z,width:"1644",height:"923"})),(0,r.kt)("p",null,"In this repository we achieved this functionality using 2 different alternate approaches, one using a bespoke proxy and another one using NGINX as reverse proxy. Using NGINX is more suitable for production environments because can protect more effectively the introspection requests, that are delegated to the OAuth Introspection server. That server has been implemented in Typescript and performs the JWT - JWE decryption, validation of the urls requested, and return of the authorization token required by the end web service to authorize the user request."),(0,r.kt)("h2",{id:"securing-web-services"},"Securing web services"),(0,r.kt)("p",null,"If clients have direct access to web services any protection introduced by a proxy can be skipped. Because of that and specially for services running in a public network it's highly recommended to configure some protections:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implement OAuth service authorization protecting that service to be accessed by anyone not able to authenticate. Via the Nevermined service registration, the OAuth token can be encripted allowing that only the asset provider can provide a valid JWT header."),(0,r.kt)("li",{parentName:"ul"},"Implement some ",(0,r.kt)("strong",{parentName:"li"},"network protection")," in the service or the access point to it. It is recommended to only allow requests comming from a trusted Nevermined proxy.")))}u.isMDXComponent=!0},56321:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/ARCH_Nginx_integration-6ae385792a11dd28f4f03ede8d7bd05f.png"}}]);