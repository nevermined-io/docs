# Context for LLM: Integrating Nevermined Payments Library with a Model Context Protocol (MCP) Server

## Objective

This document provides a comprehensive, one-shot context for an LLM to guide a developer—even one with minimal coding experience—through the process of protecting a Model Context Protocol (MCP) server with the Nevermined Payments Library. The goal is to provide all necessary information, from initial setup in the Nevermined App to final code integration, for both Python and TypeScript environments.

---

## PART 1: PREREQUISITES - CONFIGURING NEVERMINED

Before writing any code, the developer (the "Builder") must configure their agent and payment plans in the Nevermined ecosystem.

### Step 1: Get Your Builder API Key

An API key is required for the SDK to communicate with Nevermined services.

1.  **Go to the Nevermined App**: [https://nevermined.app/](https://nevermined.app/)
2.  **Log in**: Use Web3Auth (social accounts like Google, or a crypto wallet).
3.  **Navigate to Settings**: Find this in the user menu (usually top right).
4.  **Go to the API Keys tab**.
5.  **Generate a new key**: Give it a descriptive name (e.g., "MCP Server Key").
6.  **Copy and store the key securely**: This will be used as the `NVM_API_KEY` environment variable in your server application.

### Step 2: Register Your MCP Server as a Nevermined Agent and create Payment Plans

In Nevermined, an "Agent" is any service you want to monetize. You can register your agent and create its associated payment plans in a single, streamlined process using the Nevermined App.

1.  **Go to the Nevermined App** and click on “My agents” or “My pricing plans” to begin.
2.  **Register the Agent**:
    *   Fill in the metadata: Name, description, tags, etc.
    *   **Register API Endpoints**: This is the most critical step for MCP. You do **NOT** register the HTTP URL of your server (e.g., `https://api.my-server.com/mcp`). Instead, you must register the **Logical MCP URLs** for each tool, resource, and prompt you want to protect.

#### **Understanding Logical MCP URLs**

The Nevermined Payments Library identifies protected methods by a logical URL, not a physical one. This URL follows a specific format: `mcp://<serverName>/<typeName>/<methodName>`

-   `<serverName>`: A logical name for your server that you will also use in the SDK configuration (e.g., `weather-mcp`).
-   `<typeName>`: The type of MCP entity. Must be one of `tools`, `resources`, or `prompts`. For other non-standard calls like `initialize`, use `meta`.
-   `<methodName>`: The name of the specific tool, resource, or prompt.

**Examples:**
-   For the `weather.today` tool or prompt: `mcp://weather-mcp/tools/weather.today`
-   For the `weather.ensureCity` resource: `mcp://weather-mcp/resources/weather.ensureCity`
-   For the `initialize` method: `mcp://weather-mcp/meta/initialize`

**Registering URIs with Variables:**
If an URI contains dynamic parts, register it using placeholders with curly braces `{}`. The backend will match requests against these patterns.
-   For a resource like `weather://today/Madrid`: `mcp://weather-mcp/resources/weather.today?city={city}`
-   For a tool like `weather://today/Madrid`: `mcp://weather-mcp/tools/weather.today?city={city}`

3.  **Create a Payment Plan**: Plans control how users access your agent.
    *   **Credit-Based Plans**: Provides access with per-request pricing. You set a price for a bundle of credits and define the cost (in credits) for each request. When a user runs out of credits, access is denied.
    *   **Time-Based Plans**: Provides access for a specific duration (e.g., 1 month, 1 year). The user's access is valid until the time period elapses.
    *   **Trial Plans**: A special plan (usually free) that a user can only claim once, perfect for letting them try your service.

4.  **Configure Variable Credits (Important for Dynamic Pricing)**:
    *   If you plan to charge a variable amount of credits per request (using a dynamic `credits` function in your code), you **must** enable this in the plan configuration.
    *   Check the box labeled **"Want to set a price range per request?"**.
    *   Set the **"min price per request"** and **"max price per request"**.
    *   **Behavior**: If your server-side code attempts to redeem an amount of credits outside this range, the final number of credits burned will be capped by these limits. For example, if you set a max of 10 and your code calculates a cost of 15, only 10 credits will be burned.

5.  **Finalize and Get IDs**: Link the plan to your agent, publish it, and copy the `planId` and `agentId`. These are needed by subscribers.

**Best Practices for Plans:**
-   **Naming**: Use descriptive names (e.g., "Basic API Access - 1000 requests").
-   **Pricing**: Start competitive and adjust based on feedback.
-   **Trials**: Always offer trial plans to lower the barrier to entry.
-   **Endpoints**: Group related tools/resources under a single plan for better value.

---

## PART 2: SERVER-SIDE CODE INTEGRATION

With the Nevermined setup complete, the developer can now integrate the SDK into their MCP server code.

### Step 3: Install and Initialize the Payments SDK

**TypeScript:**
```bash
npm install @nevermined-io/payments
```

```typescript
// payments-setup.ts
import { Payments, EnvironmentName } from "@nevermined-io/payments";

// Get your API Key from environment variables
const payments = Payments.getInstance({
  nvmApiKey: process.env.NVM_API_KEY!,
  environment: (process.env.NVM_ENV || "sandbox") as EnvironmentName, // or "live"
});
```

**Python:**
```bash
pip install payments-py
```
```python
# payments_setup.py
import os
from payments_py.payments import Payments
payments = Payments({
    "nvm_api_key": os.environ["NVM_API_KEY"],
    "environment": os.environ.get("NVM_ENV", "sandbox"), # or "live"
})
```

### Step 4: Configure the MCP Integration

Tell the SDK about your agent. This is a one-time setup.

**TypeScript:**
```typescript
payments.mcp.configure({
    agentId: process.env.NVM_AGENT_ID!,
    serverName: "weather-mcp", // Must match the <serverName> in your logical URLs
});
```

**Python:**
```python
# For a generic or low-level server:
payments.mcp.configure({
    "agentId": os.environ["NVM_AGENT_ID"],
    "serverName": "weather-mcp", # Must match <serverName>
})
```

#### **Critical Note for FastMCP (Python High-Level Server):**
When using `FastMCP`, you **MUST** provide the `getContext` function from your `FastMCP` instance during configuration.

```python
# The fastmcp instance you created for your app
fastmcp = FastMCP(name="weather-mcp", json_response=True)

payments.mcp.configure({
    "agentId": os.environ["NVM_AGENT_ID"],
    "serverName": "weather-mcp",
    "getContext": fastmcp.get_context, # Add this line!
})
```
**Why is `getContext` needed?**
High-level frameworks like FastMCP manage the request-response cycle internally. The `with_paywall` decorator is an external wrapper and has no direct access to the raw HTTP request headers, which contain the vital `Authorization` token. The `getContext` function acts as a **bridge**. When the paywall needs the request details, it calls this function (which you provided) to fetch the current request's context, including the headers, directly from the framework. Without it, the paywall cannot authenticate the user.

### Step 5: Define Your Core Business Logic Handler

Before protecting anything, you need a standard MCP handler that contains your business logic. This function should be clean of any payment or authentication code. It takes arguments and returns a standard MCP `content` object.

**TypeScript:**
```typescript
// handlers.ts
import { ToolHandler } from "@modelcontextprotocol/sdk/server";

export const weatherToolHandler: ToolHandler = async (args) => {
    const city = (args as any).city || "Madrid";
    return {
        content: [
            { type: "text", text: `Weather for ${city}: Sunny, 25C.` },
            {
                type: "resource_link",
                uri: `weather://today/${city}`,
                name: `weather today ${city}`,
                mimeType: "application/json",
            },
        ],
    };
};
```

**Python:**
```python
# handlers.py
from typing import Any, Dict

async def weather_tool_handler(args: Dict[str, Any]) -> Dict[str, Any]:
    city = str(args.get("city", ""))
    text = f"Weather for {city}: Sunny, 25C."
    return {
        "content": [
            {"type": "text", "text": text},
            {
                "type": "resource_link",
                "uri": f"weather://today/{city}",
                "name": f"weather today {city}",
                "mimeType": "application/json",
            },
        ]
    }
```

### Step 6: Protect Handlers with `withPaywall`

This is the core function. It's a wrapper that adds the paywall logic to your existing MCP handlers without cluttering your business logic.

#### **What Happens Inside `withPaywall`? The Request Lifecycle**

When a request hits a protected handler, `withPaywall` executes a precise sequence of operations (inspired by the internal `createWrappedHandler` method):

1.  **Authentication & Request Start**:
    *   The wrapper first extracts the `Authorization: Bearer <token>` header from the request context (either via FastMCP's `getContext` or the `extra` parameter in low-level servers).
    *   It sends the token and the logical MCP URL to Nevermined's backend (this is `startProcessingRequest`).
    *   Nevermined validates the token, checks if the user has a valid subscription for that URL, and ensures they have a positive credit balance.
    *   If successful, Nevermined generates and returns a unique **`requestId`**. This ID is essential for tracking the entire lifecycle of this specific request. If validation fails, a JSON-RPC error `-32003` is returned immediately.

2.  **Business Logic Execution**:
    *   Only after successful authentication does the wrapper execute your original handler (e.g., `weather_tool_handler`) with the provided arguments.

3.  **Credit Calculation**:
    *   Once your handler returns a result, the `credits` option you configured is resolved. If it's a fixed number, that value is used. If it's a function, the function is called with a context object (`{args, result, ...}`) to dynamically calculate the cost.

4.  **Credit Redemption**:
    *   The wrapper makes a final call to Nevermined's backend (`redeemCreditsFromRequest`), sending the `requestId` from Step 1 and the calculated number of credits from Step 3.
    *   Nevermined deducts the credits from the user's balance.

5.  **Return Result**: The final result from your handler is returned to the client.

*Special Case: Streaming*: If your handler returns a stream (an `AsyncIterable`), the credit redemption (Step 4) is cleverly delayed until the stream is fully consumed or closed by the client. This ensures users are only charged if they actually use the data.

#### **Implementation Example:**

**Applying the `withPaywall` Wrapper:**

**TypeScript:**
```typescript
const protectedWeatherHandler = payments.mcp.withPaywall(
    weatherToolHandler, // Your original handler
    {
        kind: "tool", // "tool", "resource", or "prompt"
        name: "weather.today", // The <methodName>
        credits: 1n // Cost per call. Use BigInt (e.g., 1n).
    }
);

// Then, register this protected handler with your MCP server.
```

**Python:**
```python
protected_weather = payments.mcp.with_paywall(
    weather_tool_handler, # Your original handler
    {
        "kind": "tool", # "tool", "resource", or "prompt"
        "name": "weather.today", # The <methodName>
        "credits": 1, # Cost per call (integer).
    },
)
// Then, use this protected handler in your server.
```

### Step 7: How `withPaywall` Works: High-Level vs. Low-Level Servers

-   **High-Level Servers** (`FastMCP` in Python, `@modelcontextprotocol/sdk` in TS): These frameworks automatically capture incoming HTTP request headers. The paywall uses this context to find the `Authorization` token. In `FastMCP`, this only works if you provide `getContext` during configuration.
-   **Low-Level Servers** (custom ASGI/Express router): You are responsible for capturing the request headers and passing them to the handler. The protected handler expects a second argument, `extra`, which contains the request info.

**Low-Level Server Example (Python/ASGI):**
```python
from payments_py.mcp import build_extra_from_http_headers

async def my_asgi_app(scope, receive, send):
    # ...
    headers = {k.decode(): v.decode() for k, v in scope.get("headers", [])}
    extra = build_extra_from_http_headers(headers)

    # CRITICAL: Pass `extra` as the second argument
    result = await protected_handler(arguments, extra)
    # ...
```

**Low-Level Server Example (TypeScript/Express):**
```typescript
app.post("/mcp-low", async (req, res) => {
    // ...
    // CRITICAL: Construct and pass `extra` as the second argument
    const result = await protectedHandler(params.arguments, {
        requestInfo: { headers: req.headers },
    });
    // ...
});
```

### Step 8: Dynamic Credit Calculation

Instead of a fixed number, you can provide a function to the `credits` option for dynamic pricing.

**TypeScript:**
```typescript
const protectedHandler = payments.mcp.withPaywall(handler, {
    kind: "tool",
    name: "weather.today",
    credits: (ctx) => {
        const city = (ctx.args as any).city || "";
        // Charge more for longer city names
        return city.length > 10 ? 2n : 1n;
    },
});
```

**Python:**
```python
def calculate_credits(ctx: dict) -> int:
    city = (ctx.get("args") or {}).get("city", "")
    # Charge more for longer city names
    return 2 if len(city) > 10 else 1

protected_handler = payments.mcp.with_paywall(handler, {
    "kind": "tool",
    "name": "weather.today",
    "credits": calculate_credits,
})
```

### Step 9 (Alternative): Declarative Registration with `attach`

For servers with many handlers, `attach` simplifies registration and protection into one step.

**TypeScript:**
```typescript
const server = new McpServer(/*...*/);
const protectedRegistrar = payments.mcp.attach(server);

// Registers and protects the tool simultaneously
protectedRegistrar.registerTool(
    "weather.today",
    { title: "Today's Weather", ... },
    weatherToolHandler, // Original handler
    { credits: 1n } // Paywall options
);
```

**Python:**
```python
# Note: `attach` in Python works with a generic MCP server object, not FastMCP directly.
server = McpServer() # Generic server from `mcp` library
protected_registrar = payments.mcp.attach(server)

protected_registrar.registerTool(
    "weather.today",
    {"title": "Today's Weather"},
    weather_tool_handler, # Original handler
    {"credits": 1} # Paywall options
)
```

---

## PART 3: CLIENT-SIDE INTERACTION

### Step 10: Getting Access & Calling Tools

This is how a "Subscriber" (a user of your MCP agent) gets access.

1.  **Get a Subscriber API Key**: The user gets their own key from the Nevermined App, just like the builder did.
2.  **Purchase a Plan**: The user must purchase the plan created by the builder. This can be done via the App or the SDK.
3.  **Get an Access Token**: Using their API key, the `planId`, and the `agentId`, the subscriber's client application calls the SDK to get a short-lived `accessToken`.
4.  **Call the MCP Server**: The client makes standard JSON-RPC calls to the MCP server but **must include** the `Authorization` header with the token.

**Client-Side Code Example (Python):**
```python
from payments_py.payments import Payments
import requests

# Subscriber initializes with THEIR API key
subscriber_payments = Payments({"nvm_api_key": "SUBSCRIBER_API_KEY", ...})

# Get token
creds = subscriber_payments.agents.get_agent_access_token(PLAN_ID, AGENT_ID)
access_token = creds["accessToken"]

# Make authenticated request
response = requests.post(
    "http://localhost:8000/mcp",
    json={
        "jsonrpc": "2.0",
        "method": "tools/call",
        "params": {"name": "weather.today", "arguments": {"city": "Madrid"}}
    },
    headers={"Authorization": f"Bearer {access_token}"}
)
```

**Client-Side Code Example (TypeScript):**
```typescript
import { Payments } from "@nevermined-io/payments";
import { Client as McpClient, StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client";

// Subscriber initializes with THEIR API key
const subscriberPayments = Payments.getInstance({ nvmApiKey: "SUBSCRIBER_API_KEY", ... });

// Get token
const { accessToken } = await subscriberPayments.agents.getAgentAccessToken(PLAN_ID, AGENT_ID);

// Make authenticated request using MCP SDK Client
const transport = new StreamableHTTPClientTransport(new URL("http://localhost:3000/mcp"), {
    requestInit: {
        headers: { Authorization: `Bearer ${accessToken}` },
    },
});

const client = new McpClient({ name: "my-app" });
await client.connect(transport);
const result = await client.callTool({ name: "weather.today", arguments: { city: "London" } });
```

---

## PART 4: SUMMARY & ERROR HANDLING

-   **JSON-RPC Error `-32003`**: Sent for any authorization or payment issue (missing token, invalid token, insufficient credits). The message will provide more details.
-   **JSON-RPC Error `-32002`**: Sent for other internal server errors during the paywall process.
-   **Success**: If authentication and payment succeed, the client receives the normal MCP response from the handler.
