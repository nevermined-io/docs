---
title: "AI Use Cases"
---

# AI Use Cases

## Overview

Nevermined enables various AI monetization scenarios, from simple API access to complex agent-to-agent transactions. Here are real-world use cases and implementation examples.

## 1. Code Review Assistant

A specialized AI agent that analyzes code quality, suggests improvements, and identifies potential bugs.

### Implementation Example

```typescript
import { Payments, getERC20PriceConfig, getFixedCreditsConfig } from '@nevermined-io/payments'

const payments = Payments.getInstance({
  nvmApiKey: process.env.NVM_API_KEY,
  environment: 'production'
})

// Define the Code Review Agent
const agentMetadata = {
  name: 'Code Review Assistant',
  tags: ['development', 'code-review', 'ai'],
  dateCreated: new Date(),
  description: 'AI-powered code review and suggestions'
}

const agentApi = {
  endpoints: [
    { POST: 'https://api.codeassistant.com/review' },
    { GET: 'https://api.codeassistant.com/status' }
  ]
}

// Pricing: 10 USDC for 100 reviews
const priceConfig = getERC20PriceConfig(
  10_000_000n, // 10 USDC
  '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC address
  builderAddress
)

const creditsConfig = getFixedCreditsConfig(100n, 1n) // 100 credits, 1 per review

// Register the agent
const { agentId, planId } = await payments.registerAgentAndPlan(
  agentMetadata,
  agentApi,
  priceConfig,
  creditsConfig
)
```

### Usage Pattern
- Developers purchase credits to review their code
- Each review consumes 1 credit
- Agent analyzes code complexity, security issues, and best practices
- Results include actionable improvements and explanations

## 2. AI Legal Document Analyzer

An agent that reviews contracts, identifies key terms, and flags potential risks.

### Multi-Tier Pricing Example

```typescript
// Basic Plan: Simple document review
const basicPrice = getERC20PriceConfig(5_000_000n, USDC_ADDRESS, builderAddress)
const basicCredits = getFixedCreditsConfig(50n, 1n)
const { planId: basicPlanId } = await payments.registerCreditsPlan(basicPrice, basicCredits)

// Premium Plan: Deep analysis with recommendations
const premiumPrice = getERC20PriceConfig(20_000_000n, USDC_ADDRESS, builderAddress)
const premiumCredits = getFixedCreditsConfig(250n, 1n)
const { planId: premiumPlanId } = await payments.registerCreditsPlan(premiumPrice, premiumCredits)

// Enterprise Plan: Unlimited monthly access
const enterprisePrice = getERC20PriceConfig(100_000_000n, USDC_ADDRESS, builderAddress)
const enterpriseCredits = getExpirablePlanCreditsConfig(86400n * 30n) // 30 days
const { planId: enterprisePlanId } = await payments.registerTimePlan(enterprisePrice, enterpriseCredits)

// Register agent with all plans
const { agentId } = await payments.registerAgent(
  legalAgentMetadata,
  legalAgentApi,
  [basicPlanId, premiumPlanId, enterprisePlanId]
)
```

## 3. Computer Vision API with Dynamic Pricing

An image processing service that charges based on computational complexity.

### Dynamic Credits Implementation

```typescript
const visionAgentMetadata = {
  name: 'Vision AI Pro',
  tags: ['computer-vision', 'image-processing', 'ai'],
  dateCreated: new Date(),
  description: 'Advanced image analysis and object detection'
}

// Dynamic pricing based on image complexity
const dynamicCredits = {
  creditsType: 'DYNAMIC',
  minCreditsPerRequest: 1n,    // Simple image detection
  maxCreditsPerRequest: 50n,   // Complex scene analysis
  amount: 1000n                 // Total credits in plan
}

const { agentId, planId } = await payments.registerAgentAndPlan(
  visionAgentMetadata,
  visionAgentApi,
  priceConfig,
  dynamicCredits
)

// In your agent endpoint
app.post('/api/analyze', async (req, res) => {
  // Validate access
  const isValid = await payments.isValidRequest(
    planId,
    agentId,
    req.body.subscriberAddress,
    req.headers['x-nvm-query-signature']
  )

  if (!isValid) {
    return res.status(402).json(await payments.getAgentPaymentCard(agentId))
  }

  // Process image and calculate complexity
  const result = await analyzeImage(req.body.imageData)
  const complexity = calculateImageComplexity(req.body.imageData, result)
  
  // Redeem credits based on complexity
  const creditsUsed = Math.min(Math.max(complexity, 1), 50)
  await payments.redeemCredits(planId, BigInt(creditsUsed), generateProof(req, result))

  res.json({ result, creditsUsed })
})
```

## 4. Agent-to-Agent Transaction: AI Workflow

Multiple agents working together in a content creation pipeline.

### Workflow Example

```typescript
// Agent 1: Content Generator
const contentAgent = {
  name: 'AI Content Writer',
  endpoints: [{ POST: 'https://api.contentai.com/generate' }]
}

// Agent 2: Grammar Checker
const grammarAgent = {
  name: 'Grammar AI',
  endpoints: [{ POST: 'https://api.grammarai.com/check' }]
}

// Agent 3: SEO Optimizer
const seoAgent = {
  name: 'SEO Optimizer AI',
  endpoints: [{ POST: 'https://api.seoai.com/optimize' }]
}

// Orchestrator agent that uses all three
async function createOptimizedContent(topic: string) {
  // 1. Generate content
  const contentCredentials = await payments.getAgentHTTPOptions(contentPlanId, contentAgentId)
  const content = await payments.query(contentAgentId, contentCredentials, {
    prompt: `Write an article about ${topic}`
  })

  // 2. Check grammar
  const grammarCredentials = await payments.getAgentHTTPOptions(grammarPlanId, grammarAgentId)
  const corrected = await payments.query(grammarAgentId, grammarCredentials, {
    text: content.result
  })

  // 3. Optimize for SEO
  const seoCredentials = await payments.getAgentHTTPOptions(seoPlanId, seoAgentId)
  const optimized = await payments.query(seoAgentId, seoCredentials, {
    content: corrected.result,
    keywords: ['AI', 'monetization']
  })

  return optimized.result
}
```

## 5. AI Model Training Service

Provide compute resources for training custom models with usage-based billing.

### Time and Resource Based Pricing

```typescript
const trainingAgentMetadata = {
  name: 'AI Training Cloud',
  tags: ['ml-training', 'gpu', 'compute'],
  dateCreated: new Date(),
  description: 'Distributed GPU compute for model training'
}

// Charge per GPU hour
const gpuHourPrice = getERC20PriceConfig(
  50_000_000n, // 50 USDC per GPU hour
  USDC_ADDRESS,
  builderAddress
)

// Credits represent compute time
const computeCredits = {
  creditsType: 'DYNAMIC',
  minCreditsPerRequest: 1n,     // 1 GPU hour minimum
  maxCreditsPerRequest: 168n,   // 1 week maximum
  amount: 1000n                 // Total GPU hours in plan
}

// Training endpoint with progress tracking
app.post('/api/train', async (req, res) => {
  const isValid = await payments.isValidRequest(...)
  
  if (!isValid) {
    return res.status(402).json(await payments.getAgentPaymentCard(agentId))
  }

  // Start training job
  const jobId = await startTrainingJob(req.body.model, req.body.dataset)
  
  // Monitor and bill based on actual usage
  const gpuHoursUsed = await monitorJob(jobId)
  await payments.redeemCredits(planId, BigInt(gpuHoursUsed), generateJobProof(jobId))

  res.json({ jobId, gpuHoursUsed, status: 'completed' })
})
```

## 6. Real-time Translation API

A high-frequency service for instant language translation.

### Subscription Model

```typescript
// Monthly unlimited plan
const monthlyPrice = getFiatPriceConfig(
  29_000_000n, // $29 USD
  builderAddress
)

const monthlyCredits = getExpirablePlanCreditsConfig(86400n * 30n) // 30 days

// Per-request plan for occasional users
const payPerUsePrice = getERC20PriceConfig(
  100_000n, // 0.10 USDC per request
  USDC_ADDRESS,
  builderAddress
)

const payPerUseCredits = getFixedCreditsConfig(1000n, 1n) // 1000 translations
```

## Best Practices for AI Use Cases

### 1. Price Discovery
- Start with competitive pricing
- Monitor usage patterns
- Adjust based on demand and costs

### 2. Credit Allocation
- Match credits to actual compute costs
- Consider request complexity
- Implement fair usage policies

### 3. User Experience
- Provide clear pricing information
- Show credit usage in real-time
- Offer trial credits for new users

### 4. Performance Optimization
- Cache frequent requests
- Batch process when possible
- Use efficient credit redemption

### 5. Security Considerations
- Validate all inputs
- Implement rate limiting
- Monitor for abuse patterns

## Conclusion

These use cases demonstrate the flexibility of Nevermined for various AI monetization scenarios. Whether you're building a simple API service or a complex multi-agent system, Nevermined provides the infrastructure for secure, scalable payments.