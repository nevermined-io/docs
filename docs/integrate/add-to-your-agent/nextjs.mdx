---
title: "Next.js Integration"
description: "Add Nevermined payments to your Next.js application"
icon: "react"
frameworks: ["nextjs", "react", "vercel"]
---

<Note>
  **Start here:** need to register a service and create a plan first? Follow the
  [5-minute setup](/docs/integrate/quickstart/5-minute-setup).
</Note>

Complete guide to integrating Nevermined payments into Next.js API routes and server actions.

## Installation

```bash
npm install @nevermined-io/payments
```

## Project Setup

```typescript filename="lib/payments.ts"
import { Payments } from '@nevermined-io/payments'

// Singleton for server-side use
let paymentsInstance: Payments | null = null

export function getPayments(): Payments {
  if (!paymentsInstance) {
    paymentsInstance = Payments.getInstance({
      nvmApiKey: process.env.NVM_API_KEY!,
      environment: process.env.NODE_ENV === 'production' ? 'production' : 'testing'
    })
  }
  return paymentsInstance
}

export const config = {
  agentId: process.env.AGENT_ID!,
  planId: process.env.PLAN_ID!
}
```

## API Route Handler (App Router)

```typescript filename="app/api/query/route.ts"
import { NextRequest, NextResponse } from 'next/server'
import { getPayments, config } from '@/lib/payments'

export async function POST(request: NextRequest) {
  // Extract Bearer token
  const authHeader = request.headers.get('authorization')

  if (!authHeader?.startsWith('Bearer ')) {
    return NextResponse.json(
      {
        error: 'Payment Required',
        code: 'MISSING_TOKEN',
        plans: [{ planId: config.planId, agentId: config.agentId }]
      },
      { status: 402 }
    )
  }

  const token = authHeader.substring(7)
  const body = await request.json()

  // Validate payment
  const payments = getPayments()
  const { isValid, balance, reason } = await payments.requests.isValidRequest(
    token,
    body
  )

  if (!isValid) {
    return NextResponse.json(
      {
        error: 'Payment Required',
        code: 'INVALID_TOKEN',
        reason,
        plans: [{ planId: config.planId, agentId: config.agentId }]
      },
      { status: 402 }
    )
  }

  // Process the request
  const { prompt } = body
  const result = await processQuery(prompt)

  return NextResponse.json({
    result,
    credits: {
      remaining: balance,
      used: 1
    }
  })
}

async function processQuery(prompt: string): Promise<string> {
  // Your AI logic here
  return `Response to: ${prompt}`
}
```

## Middleware for Multiple Routes

```typescript filename="lib/withPayment.ts"
import { NextRequest, NextResponse } from 'next/server'
import { getPayments, config } from './payments'

export type PaymentContext = {
  isValid: boolean
  balance: number
  subscriberAddress?: string
}

export type HandlerWithPayment = (
  request: NextRequest,
  context: { payment: PaymentContext }
) => Promise<NextResponse>

export function withPayment(handler: HandlerWithPayment) {
  return async (request: NextRequest): Promise<NextResponse> => {
    const authHeader = request.headers.get('authorization')

    if (!authHeader?.startsWith('Bearer ')) {
      return NextResponse.json(
        {
          error: 'Payment Required',
          code: 'MISSING_TOKEN',
          plans: [{ planId: config.planId, agentId: config.agentId }]
        },
        { status: 402 }
      )
    }

    const token = authHeader.substring(7)

    try {
      const body = await request.clone().json()
      const payments = getPayments()
      const result = await payments.requests.isValidRequest(token, body)

      if (!result.isValid) {
        return NextResponse.json(
          {
            error: 'Payment Required',
            code: 'INVALID_TOKEN',
            reason: result.reason,
            plans: [{ planId: config.planId, agentId: config.agentId }]
          },
          { status: 402 }
        )
      }

      return handler(request, {
        payment: {
          isValid: true,
          balance: result.balance,
          subscriberAddress: result.subscriberAddress
        }
      })
    } catch (error) {
      console.error('Payment validation error:', error)
      return NextResponse.json(
        { error: 'Payment validation failed' },
        { status: 500 }
      )
    }
  }
}
```

## Using the Middleware

```typescript filename="app/api/chat/route.ts"
import { NextRequest, NextResponse } from 'next/server'
import { withPayment } from '@/lib/withPayment'

export const POST = withPayment(async (request, { payment }) => {
  const { messages } = await request.json()

  // Your AI chat logic
  const response = await generateChatResponse(messages)

  return NextResponse.json({
    message: response,
    credits: {
      remaining: payment.balance,
      used: 1
    }
  })
})

async function generateChatResponse(messages: any[]): Promise<string> {
  // Your AI implementation
  return 'Chat response...'
}
```

## Server Actions

```typescript filename="app/actions/query.ts"
'use server'

import { getPayments, config } from '@/lib/payments'
import { cookies } from 'next/headers'

export async function queryAgent(prompt: string) {
  // Get token from cookie or session
  const cookieStore = cookies()
  const token = cookieStore.get('nvm_access_token')?.value

  if (!token) {
    return {
      error: 'Payment Required',
      plans: [{ planId: config.planId, agentId: config.agentId }]
    }
  }

  const payments = getPayments()
  const { isValid, balance } = await payments.requests.isValidRequest(
    token,
    { prompt }
  )

  if (!isValid) {
    return {
      error: 'Invalid or expired token',
      plans: [{ planId: config.planId, agentId: config.agentId }]
    }
  }

  // Process query
  const result = await processQuery(prompt)

  return {
    result,
    creditsRemaining: balance
  }
}
```

## Client-Side Token Storage

```typescript filename="hooks/usePayment.ts"
'use client'

import { useState, useCallback } from 'react'

export function usePayment() {
  const [token, setToken] = useState<string | null>(null)
  const [credits, setCredits] = useState<number>(0)

  const setAccessToken = useCallback((newToken: string) => {
    setToken(newToken)
    // Also store in cookie for server actions
    document.cookie = `nvm_access_token=${newToken}; path=/; secure; samesite=strict`
  }, [])

  const query = useCallback(async (endpoint: string, data: any) => {
    if (!token) {
      throw new Error('No access token')
    }

    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(data)
    })

    if (response.status === 402) {
      const error = await response.json()
      throw new Error(error.error)
    }

    const result = await response.json()
    setCredits(result.credits?.remaining ?? credits)

    return result
  }, [token, credits])

  return {
    token,
    credits,
    setAccessToken,
    query,
    isAuthenticated: !!token
  }
}
```

## Payment UI Component

```tsx filename="components/PaymentGate.tsx"
'use client'

import { usePayment } from '@/hooks/usePayment'
import { useState } from 'react'

interface PaymentGateProps {
  planId: string
  agentId: string
  children: React.ReactNode
}

export function PaymentGate({ planId, agentId, children }: PaymentGateProps) {
  const { isAuthenticated, credits, setAccessToken } = usePayment()
  const [loading, setLoading] = useState(false)

  const handlePurchase = async () => {
    setLoading(true)
    // Redirect to purchase flow or open modal
    window.location.href = `https://nevermined.app/plan/${planId}`
  }

  if (!isAuthenticated) {
    return (
      <div className="p-6 border rounded-lg text-center">
        <h3 className="text-lg font-semibold mb-2">Access Required</h3>
        <p className="text-gray-600 mb-4">
          Purchase a plan to access this feature
        </p>
        <button
          onClick={handlePurchase}
          disabled={loading}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        >
          {loading ? 'Loading...' : 'Purchase Access'}
        </button>
      </div>
    )
  }

  return (
    <div>
      <div className="text-sm text-gray-500 mb-2">
        Credits remaining: {credits}
      </div>
      {children}
    </div>
  )
}
```

## Registration Script

```typescript filename="scripts/register.ts"
import { Payments, getERC20PriceConfig, getFixedCreditsConfig } from '@nevermined-io/payments'

const USDC_ADDRESS = '0x036CbD53842c5426634e7929541eC2318f3dCF7e'

async function register() {
  const payments = Payments.getInstance({
    nvmApiKey: process.env.NVM_API_KEY!,
    environment: 'testing'
  })

  const { agentId, planId } = await payments.agents.registerAgentAndPlan(
    {
      name: 'My Next.js App',
      description: 'AI-powered app built with Next.js',
      tags: ['nextjs', 'ai', 'react'],
      dateCreated: new Date()
    },
    {
      endpoints: [
        { POST: `${process.env.NEXT_PUBLIC_BASE_URL}/api/query` },
        { POST: `${process.env.NEXT_PUBLIC_BASE_URL}/api/chat` }
      ]
    },
    {
      name: 'Pro Plan',
      description: '100 API credits',
      dateCreated: new Date()
    },
    getERC20PriceConfig(
      10_000_000n,
      USDC_ADDRESS,
      process.env.BUILDER_ADDRESS!
    ),
    getFixedCreditsConfig(100n, 1n),
    'credits'
  )

  console.log('Registration complete!')
  console.log(`AGENT_ID=${agentId}`)
  console.log(`PLAN_ID=${planId}`)
}

register().catch(console.error)
```

## Environment Variables

```bash filename=".env.local"
# Nevermined
NVM_API_KEY=nvm:your-api-key
BUILDER_ADDRESS=0xYourWalletAddress
AGENT_ID=did:nv:your-agent-id
PLAN_ID=did:nv:your-plan-id

# Next.js
NEXT_PUBLIC_BASE_URL=http://localhost:3000
```

## Edge Runtime Compatibility

For Edge API routes:

```typescript filename="app/api/edge-query/route.ts"
import { NextRequest, NextResponse } from 'next/server'

export const runtime = 'edge'

export async function POST(request: NextRequest) {
  const authHeader = request.headers.get('authorization')

  if (!authHeader?.startsWith('Bearer ')) {
    return NextResponse.json(
      { error: 'Payment Required' },
      { status: 402 }
    )
  }

  // For Edge runtime, call validation API
  const validationResponse = await fetch(
    `${process.env.NEXT_PUBLIC_BASE_URL}/api/validate`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authHeader
      },
      body: await request.text()
    }
  )

  if (!validationResponse.ok) {
    return NextResponse.json(
      await validationResponse.json(),
      { status: validationResponse.status }
    )
  }

  // Process request
  const body = await request.json()
  const result = `Edge response to: ${body.prompt}`

  return NextResponse.json({ result })
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Payment Patterns" icon="code" href="/docs/integrate/patterns/validate-requests">
    Advanced validation patterns
  </Card>

  <Card title="TypeScript SDK" icon="book" href="/docs/api-reference/typescript/installation">
    Full API documentation
  </Card>
</CardGroup>
