---
title: "Purchase Plans"
description: "Learn how users can purchase Payment Plans to access AI services"
icon: "credit-card"
---

With the Payments Library, users and AI agents can order Payment Plans by paying for them. The process is simple and secure. The subscriber needs to have enough funds to pay for the plan in the token selected by the creator of the plan. In Nevermined, Payment Plan creators can request payments in any valid ERC-20 or native token (depending on the network where the plan is created).

As we discussed in the previous sections, Payment Plans can require payment in fiat (via Stripe integration) or crypto. Because the payment of a fiat payment plan requires the use of a credit card in a web application (via the Nevermined App), crypto payments are recommended for AI agents. That way, the payment and fetching of credits associated with the Payment Plan can be done in a single step.

## Ordering a Plan

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    // Here we are ordering the plan created in the previous steps
    const orderResult = await payments.plans.orderPlan(planId)
    // OUTPUT: orderResult:
    // {
    //   txHash: '0x5b95ebaec594b6d87e688faddf85eec3d708e6a06e61864699e5a366af1343f6',
    //   success: true
    // }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    # Here we are ordering the Plan created in the previous steps
    order_result = payments.order_plan(plan_DID)  
    # OUTPUT: orderResult:
    # { success: True, agreementId: '0xaabbcc' }
    ```
  </Tab>
</Tabs>

## Ordering Plans with Fiat Payment

When the Payment Plan requires a payment in fiat, the payment can be initiated with the libraries, but the final step needs to be done in the Nevermined App. The app will handle the payment in fiat (Stripe integration) and will return the user to the application with the Payment Plan ordered.

For fiat payments, the process involves redirecting users to a Stripe checkout session:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    // Get fiat payment configuration
    const fiatConfig = await payments.plans.getFiatPriceConfig(planId)
    
    // Order plan with fiat payment
    const { sessionId, url } = await payments.plans.orderFiatPlan(planId)
    
    // Redirect user to Stripe checkout
    window.location.href = url
    
    // After successful payment, user will be redirected back with the plan active
    ```
  </Tab>
  <Tab title="Python">
    ```python
    # Get fiat payment configuration
    fiat_config = payments.plans.get_fiat_price_config(plan_id)
    
    # Order plan with fiat payment
    fiat_result = payments.plans.order_fiat_plan(plan_id)
    
    # Redirect user to Stripe checkout
    print(f'Stripe checkout URL: {fiat_result["url"]}')
    # User completes payment on Stripe and returns to your application
    ```
  </Tab>
</Tabs>

## Checking the Credit Balance of a Payment Plan

After a user purchases a plan, they can check their balance for that plan. The balance represents the number of credits the user has available to use within the plan.

<Note>
Time-based plans provide a balance of 1 credit for subscribers. When the plan expires, this balance will be zero.
</Note>

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const balanceResult = await payments.plans.getPlanBalance(planId)
    // OUTPUT: balanceResult:
    // {
    //   planId: '84262690312400469275420649384078993542777341811308941725027729655403981619104',
    //   planType: 'credits',
    //   holderAddress: '0x8924803472bb453b7c27a3C982A08f7515D7aA72',
    //   creditsContract: '0x17FaFabF74312EdaBEB1DB9f0CaAccd44aAFDE39',
    //   balance: '100',
    //   isSubscriber: true
    // }
    ```  
  </Tab>
  <Tab title="Python">
    ```python
    balance_result = payments.get_plan_balance(plan_DID)
    # OUTPUT: balanceResult:
    # {
    #   "planType": "credits",
    #   "isSubscriptor": True,
    #   "isOwner": False,
    #   "balance": 10000000
    # }  
    ```
  </Tab>
</Tabs>

## Understanding Plan Types and Balances

<CardGroup cols={2}>
  <Card title="Credits-Based Plans" icon="coins">
    Users receive a specific number of credits upon purchase. Each API call consumes credits based on your configuration.
  </Card>
  <Card title="Time-Based Plans" icon="clock">
    Users receive 1 credit that grants unlimited access for the specified duration. Balance becomes 0 when expired.
  </Card>
</CardGroup>

## Payment Flow Examples

### Complete Purchase Flow

<Steps>
  <Step title="Discover Plans">
    Users browse available payment plans and select one that fits their needs
  </Step>
  <Step title="Initiate Purchase">
    Call `payments.plans.orderPlan()` or `payments.plans.orderFiatPlan()` depending on payment method
  </Step>
  <Step title="Complete Payment">
    For crypto: transaction is processed on-chain and happens in one transaction.
    For fiat: user completes Stripe checkout, and the credits will be distributed automatically after the payment.
  </Step>
  <Step title="Verify Purchase">
    Check balance to confirm the plan was successfully purchased and get the balance. Call `payments.plans.getPlanBalance()`.
  </Step>
  <Step title="Access Services">
    Use the plan to access AI agents and services. Call `payments.agents.getAgentAccessToken()`.
  </Step>
</Steps>

### Error Handling

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    try {
      const orderResult = await payments.plans.orderPlan(planId)
      
      if (orderResult.success) {
        console.log('Plan purchased successfully!')
        console.log('Transaction hash:', orderResult.txHash)
        
        // Check balance to confirm
        const balance = await payments.plans.getPlanBalance(planId)
        console.log('Available credits:', balance.balance)
      }
    } catch (error) {
      console.error('Purchase failed:', error.message)
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    try:
        order_result = payments.order_plan(plan_id)
        
        if order_result.get('success'):
            print('Plan purchased successfully!')
            print(f'Agreement ID: {order_result.get("agreementId")}')
            
            # Check balance to confirm
            balance = payments.get_plan_balance(plan_id)
            print(f'Available credits: {balance.get("balance")}')
            
    except Exception as error:
        print(f'Purchase failed: {error}')
        
    ```
  </Tab>
</Tabs>

## Best Practices for Plan Purchasing

<AccordionGroup>
  <Accordion title="User Experience">
    - Always show clear pricing and what users get for their purchase
    - Create different plans for crypto and fiat payments if you want to support both
    - Show plan benefits and limitations clearly
  </Accordion>
  
  <Accordion title="Error Handling">
    - Handle network failures gracefully with retry mechanisms
    - Provide clear error messages for common issues
    - Allow users to check their balance before making additional purchases
    - Implement transaction status checking for pending purchases
  </Accordion>
  
  <Accordion title="Security">
    - Never store private keys or sensitive wallet information
    - Validate plan purchases on the backend before granting access
    - Implement rate limiting to prevent abuse
    - Log purchase events for audit trails
  </Accordion>
</AccordionGroup>


## Next Steps

After users purchase plans, they can:

<CardGroup cols={2}>
  <Card title="Query AI Agents" icon="search" href="/integration-guide/query-agents">
    Learn how to access AI services with purchased plans
  </Card>
  <Card title="Handle Requests" icon="chart-line" href="/integration-guide/process-requests">
    Learn how to process requests and manage responses
  </Card>
</CardGroup>
