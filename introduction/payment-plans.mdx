---
title: 'Payment Plans'
description: 'Design flexible pricing models for your AI services'
icon: 'money-bill'
---

## Overview

Payment plans define how subscribers pay for and access your AI services. Nevermined supports multiple pricing models to match your business needs.

<CardGroup cols={4}>
  <Card title="Usage-Based" icon="coins" href="#usage-based-plans">
    Pay per request
  </Card>
  <Card title="Time-Based" icon="clock" href="#time-based-plans">
    Subscription model
  </Card>
  <Card title="Hybrid" icon="layer-group" href="#hybrid-plans">
    Combined approach
  </Card>
  <Card title="Trial" icon="gift" href="#trial-plans">
    Free or limited access
  </Card>
</CardGroup>

## Plan Components

Every payment plan consists of two main configurations:

### 1. Price Configuration

Defines the cost and payment details:

```typescript
interface PriceConfig {
  priceType: 'FIXED_PRICE' | 'DYNAMIC_PRICE'
  tokenAddress: string      // Token contract or '0x0' for native
  amounts: bigint[]        // Payment amounts
  receivers: string[]      // Who receives payment
}
```

### 2. Credits Configuration

Defines what subscribers receive:

```typescript
interface CreditsConfig {
  creditsType: 'FIXED' | 'EXPIRABLE' | 'DYNAMIC'
  amount: bigint                    // Total credits
  creditsPerRequest?: bigint        // Credits per use
  minCreditsPerRequest?: bigint     // For dynamic pricing
  maxCreditsPerRequest?: bigint     // For dynamic pricing  
  durationOfThePlan?: bigint        // For time-based plans
}
```

## Usage-Based Plans

Perfect for pay-as-you-go services where users pay for what they consume.

### Fixed Credits Example

```typescript
import { 
  getERC20PriceConfig, 
  getFixedCreditsConfig 
} from '@nevermined-io/payments'

// 10 USDC for 100 API calls
const planMetadata = {
  name: 'Basic Usage Plan',
  description: '100 API calls with standard processing',
  dateCreated: new Date()
}

const priceConfig = getERC20PriceConfig(
  10_000_000n, // 10 USDC (6 decimals)
  '0xA0b86a33E6441c41F4F2B8Bf4F2B0f1B0F1C1C1C', // USDC address
  builderAddress
)

const creditsConfig = getFixedCreditsConfig(
  100n, // Total credits
  1n    // 1 credit per request
)

const { planId } = await payments.plans.registerCreditsPlan(
  planMetadata,
  priceConfig,
  creditsConfig
)
```

### Dynamic Credits Example

For services where usage varies by request:

```typescript
// 50 USDC for 1000 credits (variable consumption)
const planMetadata = {
  name: 'Dynamic Usage Plan',
  description: 'Variable credit consumption based on complexity'
}

const priceConfig = getERC20PriceConfig(50_000_000n, USDC_ADDRESS, builderAddress)

const dynamicCreditsConfig = {
  creditsType: 'DYNAMIC',
  amount: 1000n,
  minCreditsPerRequest: 1n,   // Minimum 1 credit
  maxCreditsPerRequest: 50n   // Maximum 50 credits
}

const { planId } = await payments.plans.registerCreditsPlan(
  planMetadata,
  priceConfig,
  dynamicCreditsConfig
)

// In your endpoint, credits are automatically calculated
// based on the request complexity by the Nevermined system
```

## Time-Based Plans

Ideal for subscription services with unlimited or high-volume usage.

### Monthly Subscription

```typescript
import { 
  getFiatPriceConfig, 
  getExpirablePlanCreditsConfig 
} from '@nevermined-io/payments'

// $29.99/month via Stripe
const planMetadata = {
  name: 'Monthly Subscription',
  description: 'Unlimited access for 30 days'
}

const priceConfig = getFiatPriceConfig(
  29_990_000n, // $29.99 (8 decimals)
  builderAddress
)

const timeConfig = getExpirableDurationConfig(
  86400n * 30n // 30 days in seconds
)

const { planId } = await payments.plans.registerTimePlan(
  planMetadata,
  priceConfig,
  timeConfig
)
```

### Annual Subscription

```typescript
// $299/year (with discount)
const planMetadata = {
  name: 'Annual Subscription',
  description: 'Best value - save 20% with annual billing'
}

const priceConfig = getFiatPriceConfig(299_000_000n, builderAddress)
const timeConfig = getExpirableDurationConfig(86400n * 365n)

const { planId } = await payments.plans.registerTimePlan(
  planMetadata,
  priceConfig,
  timeConfig
)
```

## Hybrid Plans

Combine time limits with usage limits for maximum flexibility.

### Example: Monthly Plan with Usage Cap

```typescript
// $49/month for up to 1000 requests
const planMetadata = {
  name: 'Pro Monthly',
  description: '1000 requests per month with priority processing'
}

const priceConfig = getFiatPriceConfig(49_000_000n, builderAddress)

const hybridCreditsConfig = {
  creditsType: 'EXPIRABLE',
  amount: 1000n,
  creditsPerRequest: 1n,
  durationOfThePlan: 86400n * 30n // Expires after 30 days
}

const { planId } = await payments.plans.registerCreditsPlan(
  planMetadata,
  priceConfig,
  hybridCreditsConfig
)
```

## Trial Plans

Perfect for letting users test your service before committing to a paid plan.

### Time-Based Trial

Offer free access for a limited time:

```typescript
// 7-day free trial
const trialMetadata = {
  name: 'Free Trial',
  description: '7 days of unlimited access'
}

const { planId } = await payments.plans.registerTimeTrialPlan(
  trialMetadata,
  86400n * 7n // 7 days in seconds
)
```

### Credits-Based Trial

Provide a limited number of free credits:

```typescript
// 10 free credits trial
const trialMetadata = {
  name: 'Starter Trial',
  description: 'Try 10 requests for free'
}

const { planId } = await payments.plans.registerCreditsTrialPlan(
  trialMetadata,
  10n, // Total free credits
  1n   // Credits per request
)
```

### Trial Plan Features

<Note>
Trial plans have special characteristics:
- **No payment required** - Users can start immediately
- **One-time use** - Each user can only claim a trial once
- **Auto-expiry** - Time trials expire automatically
- **Conversion tracking** - Monitor trial-to-paid conversions
</Note>

### Best Practices for Trials

<AccordionGroup>
  <Accordion title="Trial Length">
    - Time trials: 7-14 days is typical
    - Credit trials: 10-50 requests depending on complexity
    - Consider your sales cycle when setting duration
  </Accordion>
  
  <Accordion title="Feature Access">
    - Provide full feature access to showcase value
    - Or limit to basic features to encourage upgrades
    - Be transparent about trial limitations
  </Accordion>
  
  <Accordion title="Conversion Strategy">
    - Send reminders before trial expires
    - Offer special pricing for trial users
    - Make upgrade process seamless
    - Track conversion metrics
  </Accordion>
</AccordionGroup>

## Multi-Tier Pricing

Offer different plans for different customer segments:

```typescript
async function createTieredPricing() {
  const payments = Payments.getInstance({
    nvmApiKey: process.env.NVM_API_KEY,
    environment: 'production'
  })

  // Basic Tier - $9.99 for 100 requests
  const basicMetadata = { name: 'Basic', description: 'For individuals' }
  const basicPrice = getFiatPriceConfig(9_990_000n, builderAddress)
  const basicCredits = getFixedCreditsConfig(100n, 1n)
  const { planId: basicPlan } = await payments.plans.registerCreditsPlan(
    basicMetadata,
    basicPrice, 
    basicCredits
  )

  // Pro Tier - $49.99 for 1000 requests
  const proMetadata = { name: 'Pro', description: 'For growing teams' }
  const proPrice = getFiatPriceConfig(49_990_000n, builderAddress)
  const proCredits = getFixedCreditsConfig(1000n, 1n)
  const { planId: proPlan } = await payments.plans.registerCreditsPlan(
    proMetadata,
    proPrice, 
    proCredits
  )

  // Enterprise Tier - $199/month unlimited
  const enterpriseMetadata = { name: 'Enterprise', description: 'For large organizations' }
  const enterprisePrice = getFiatPriceConfig(199_000_000n, builderAddress)
  const enterpriseTime = getExpirableDurationConfig(86400n * 30n)
  const { planId: enterprisePlan } = await payments.plans.registerTimePlan(
    enterpriseMetadata,
    enterprisePrice, 
    enterpriseTime
  )

  // Register agent with all plans
  const { agentId } = await payments.agents.registerAgent(
    agentMetadata,
    agentApi,
    [basicPlan, proPlan, enterprisePlan]
  )

  return { agentId, plans: { basicPlan, proPlan, enterprisePlan } }
}
```

## Payment Methods

### Cryptocurrency (ERC-20 Tokens)

```typescript
// Accept USDC
const usdcPrice = getERC20PriceConfig(
  10_000_000n, // 10 USDC
  '0xA0b86a33E6441c41F4F2B8Bf4F2B0f1B0F1C1C1C', // USDC contract
  builderAddress
)

// Accept custom token
const customPrice = getERC20PriceConfig(
  1000_000_000_000_000_000n, // 1 token (18 decimals)
  '0xYourTokenAddress',
  builderAddress
)
```

### Fiat Currency (via Stripe)

```typescript
// Accept USD via credit card
const fiatPrice = getFiatPriceConfig(
  25_000_000n, // $25.00
  builderAddress
)
```

## Advanced Pricing Strategies

### Volume Discounts

Create plans with better rates for higher volume:

```typescript
const plans = [
  { credits: 100n, price: 10_000_000n },   // $0.10 per credit
  { credits: 1000n, price: 80_000_000n },  // $0.08 per credit
  { credits: 10000n, price: 500_000_000n } // $0.05 per credit
]

for (const tier of plans) {
  const metadata = {
    name: `${tier.credits} Credits Pack`,
    description: `$${tier.price / 1_000_000} per credit`
  }
  const price = getERC20PriceConfig(tier.price, USDC_ADDRESS, builderAddress)
  const credits = getFixedCreditsConfig(tier.credits, 1n)
  await payments.plans.registerCreditsPlan(metadata, price, credits)
}
```

### Feature-Based Pricing

Different credit consumption for different features:

```typescript
// In your endpoint logic
async function processRequest(feature: string, req: Request) {
  const creditCosts = {
    'basic-query': 1n,
    'advanced-analysis': 5n,
    'premium-generation': 10n,
    'enterprise-batch': 25n
  }

  const creditsRequired = creditCosts[feature] || 1n
  
  // With bearer token authentication, validation happens automatically
  // The proxy or your validation middleware handles credit checks
  
  // Process the request - credits are deducted automatically
  const result = await processFeature(feature, req)
  
  // Optionally log the usage for analytics
  // await payments.requests.logRequest(token, { 
  //   feature,
  //   creditsUsed: creditsRequired 
  // })
  
  return result
}
```

### Revenue Sharing

Split payments between multiple parties:

```typescript
const revenueSharePrice = {
  priceType: 'FIXED_PRICE',
  tokenAddress: USDC_ADDRESS,
  amounts: [
    7_000_000n,  // 70% to main developer
    2_000_000n,  // 20% to data provider
    1_000_000n   // 10% to platform
  ],
  receivers: [
    developerAddress,
    dataProviderAddress,
    platformAddress
  ]
}

const planMetadata = {
  name: 'Revenue Share Plan',
  description: 'Collaborative pricing with multiple beneficiaries'
}

const { planId } = await payments.plans.registerCreditsPlan(
  planMetadata,
  revenueSharePrice,
  creditsConfig
)
```

## Plan Management

### Updating Plans

Plans are immutable once created, but you can:

1. Create new plans with updated pricing
2. Add new plans to existing agents
3. Deprecate old plans (stop promoting them)

```typescript
// Create and add a new plan to existing agent
const newPlanMetadata = { name: 'Limited Time Offer', description: '50% off' }
const newPriceConfig = getFiatPriceConfig(14_990_000n, builderAddress)
const newCreditsConfig = getFixedCreditsConfig(500n, 1n)

const { planId: newPlanId } = await payments.plans.registerCreditsPlan(
  newPlanMetadata,
  newPriceConfig,
  newCreditsConfig
)

// Associate the new plan with the agent
await payments.agents.addPlanToAgent(agentId, newPlanId)
```

### Plan Analytics

Track plan performance:

```typescript
async function analyzePlanPerformance(planId: string) {
  const plan = await payments.plans.getPlan(planId)
  const balance = await payments.plans.getPlanBalance(planId, subscriberAddress)
  
  // Get subscriber count and usage metrics
  const metrics = {
    planId,
    planName: plan.metadata.name,
    price: plan.priceConfig.amounts[0],
    totalCredits: plan.creditsConfig.amount,
    creditsPerRequest: plan.creditsConfig.creditsPerRequest,
    currentBalance: balance.credits,
    subscriberStatus: balance.subscriberStatus
    // Add your custom analytics
  }
  
  return metrics
}
```

## Best Practices

<AccordionGroup>
  <Accordion icon="lightbulb" title="Pricing Strategy">
    - Research competitor pricing
    - Start with simple plans
    - A/B test different price points
    - Consider freemium options
    - Offer clear value propositions
  </Accordion>
  
  <Accordion icon="users" title="Customer Segmentation">
    - Individual developers (low volume, price sensitive)
    - Startups (medium volume, feature focused)
    - Enterprise (high volume, SLA requirements)
    - Offer appropriate plans for each segment
  </Accordion>
  
  <Accordion icon="chart-line" title="Usage Patterns">
    - Monitor actual usage vs. allocated credits
    - Adjust credit allocations based on data
    - Consider peak usage times
    - Plan for seasonal variations
  </Accordion>
  
  <Accordion icon="shield" title="Plan Security">
    - Set reasonable rate limits
    - Monitor for abuse patterns
    - Implement usage caps where appropriate
    - Have clear terms of service
  </Accordion>
</AccordionGroup>

## Example: Complete Pricing Implementation

```typescript
import { 
  Payments,
  getERC20PriceConfig,
  getFiatPriceConfig,
  getFixedCreditsConfig,
  getExpirablePlanCreditsConfig
} from '@nevermined-io/payments'

class PricingManager {
  private payments: Payments
  
  constructor() {
    this.payments = Payments.getInstance({
      nvmApiKey: process.env.NVM_API_KEY,
      environment: 'production'
    })
  }

  async setupCompletePricing(agentMetadata, agentApi) {
    const plans = []

    // Free Trial - 10 requests
    const trialMeta = { name: 'Free Trial', description: 'Try before you buy' }
    const trialPrice = getERC20PriceConfig(0n, USDC_ADDRESS, builderAddress)
    const trialCredits = getFixedCreditsConfig(10n, 1n)
    const trial = await this.payments.plans.registerCreditsPlan(
      trialMeta, trialPrice, trialCredits
    )
    plans.push(trial.planId)

    // Pay-as-you-go - $0.10 per request
    const paygoMeta = { name: 'Pay as You Go', description: 'Perfect for testing' }
    const paygoPrice = getERC20PriceConfig(10_000_000n, USDC_ADDRESS, builderAddress)
    const paygoCredits = getFixedCreditsConfig(100n, 1n)
    const paygo = await this.payments.plans.registerCreditsPlan(
      paygoMeta, paygoPrice, paygoCredits
    )
    plans.push(paygo.planId)

    // Monthly Pro - $49/month for 1000 requests
    const proMeta = { name: 'Pro Monthly', description: 'Best for regular users' }
    const proPrice = getFiatPriceConfig(49_000_000n, builderAddress)
    const proCredits = {
      creditsType: 'EXPIRABLE',
      amount: 1000n,
      creditsPerRequest: 1n,
      durationOfThePlan: 86400n * 30n
    }
    const pro = await this.payments.plans.registerCreditsPlan(
      proMeta, proPrice, proCredits
    )
    plans.push(pro.planId)

    // Enterprise - Custom pricing
    const entMeta = { name: 'Enterprise', description: 'Unlimited monthly access' }
    const enterprisePrice = getFiatPriceConfig(499_000_000n, builderAddress)
    const enterpriseTime = getExpirableDurationConfig(86400n * 30n)
    const enterprise = await this.payments.plans.registerTimePlan(
      entMeta, enterprisePrice, enterpriseTime
    )
    plans.push(enterprise.planId)

    // Register agent with all plans
    const { agentId } = await this.payments.agents.registerAgent(
      agentMetadata,
      agentApi,
      plans
    )

    return {
      agentId,
      plans: {
        trial: trial.planId,
        paygo: paygo.planId,
        pro: pro.planId,
        enterprise: enterprise.planId
      }
    }
  }
}
```

## Next Steps

- [Implement payment validation](/introduction/integration-guide)
- [Handle different credit types](/introduction/core-concepts#credits-system)
- [See pricing examples](/introduction/example-apps)
- [Go live with your plans](/introduction/go-live-checklist)