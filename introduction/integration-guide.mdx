---
title: 'Integration Guide'
description: 'Step-by-step guide to integrate Nevermined into your AI service'
icon: 'plug'
---

## Integration Options

Choose the integration approach that best fits your architecture:

<CardGroup cols={3}>
  <Card title="Direct Integration" icon="code" href="#direct-integration">
    Add Nevermined to your code
  </Card>
  <Card title="Middleware Pattern" icon="layer-group" href="#middleware-pattern">
    Reusable authentication layer
  </Card>
  <Card title="Proxy Integration" icon="shield" href="#proxy-integration">
    No code changes required
  </Card>
</CardGroup>

## Direct Integration

Best for new services or when you want full control over the payment flow.

### Step 1: Install Dependencies

```bash
npm install @nevermined-io/payments express
npm install --save-dev @types/express typescript
```

### Step 2: Initialize Nevermined

```typescript
import { Payments } from '@nevermined-io/payments'
import express from 'express'

const app = express()
app.use(express.json())

const payments = Payments.getInstance({
  nvmApiKey: process.env.NVM_API_KEY,
  environment: 'production'
})
```

### Step 3: Create Protected Endpoint

```typescript
app.post('/api/query', async (req, res) => {
  try {
    // Extract payment information
    const { planId, agentId, subscriberAddress, prompt } = req.body
    const signature = req.headers['x-nvm-query-signature'] as string

    // Validate access
    const isValid = await payments.isValidRequest(
      planId,
      agentId,
      subscriberAddress,
      signature
    )

    if (!isValid) {
      const paymentCard = await payments.getAgentPaymentCard(agentId)
      return res.status(402).json({
        error: 'Payment required',
        message: 'Please purchase a plan to access this service',
        paymentCard
      })
    }

    // Process the AI request
    const result = await processAIRequest(prompt)

    // Redeem credits
    await payments.redeemCredits(
      planId,
      1n, // Credits to consume
      { 
        requestId: req.id,
        prompt: prompt.substring(0, 100),
        timestamp: Date.now()
      }
    )

    // Return response with usage info
    const balance = await payments.getPlanBalance(planId, subscriberAddress)
    
    res.json({
      result,
      usage: {
        creditsUsed: 1,
        creditsRemaining: balance.credits.toString()
      }
    })

  } catch (error) {
    console.error('Request failed:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
})

async function processAIRequest(prompt: string) {
  // Your AI logic here
  return { response: `Processed: ${prompt}` }
}
```

### Step 4: Add Health Check

```typescript
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    service: 'ai-agent',
    version: '1.0.0'
  })
})
```

### Step 5: Register Your Agent

```typescript
import { 
  getERC20PriceConfig, 
  getFixedCreditsConfig 
} from '@nevermined-io/payments'

async function setupAgent() {
  const metadata = {
    name: 'My AI Service',
    tags: ['ai', 'nlp'],
    dateCreated: new Date(),
    description: 'Advanced AI processing service'
  }

  const api = {
    endpoints: [
      { POST: 'https://api.myservice.com/api/query' }
    ],
    openEndpoints: [
      'https://api.myservice.com/health'
    ]
  }

  const price = getERC20PriceConfig(
    10_000_000n, // 10 USDC
    USDC_ADDRESS,
    process.env.BUILDER_ADDRESS
  )

  const credits = getFixedCreditsConfig(100n, 1n)

  const { agentId, planId } = await payments.registerAgentAndPlan(
    metadata,
    api,
    price,
    credits
  )

  console.log('Agent ID:', agentId)
  console.log('Plan ID:', planId)
}
```

## Middleware Pattern

Create reusable authentication middleware for Express/Node.js applications.

### Create Auth Middleware

```typescript
import { Request, Response, NextFunction } from 'express'
import { Payments } from '@nevermined-io/payments'

interface NeverminedRequest extends Request {
  nevermined?: {
    planId: string
    agentId: string
    subscriberAddress: string
  }
}

export function createNeverminedAuth(payments: Payments) {
  return (agentId: string) => {
    return async (
      req: NeverminedRequest, 
      res: Response, 
      next: NextFunction
    ) => {
      try {
        const { planId, subscriberAddress } = req.body
        const signature = req.headers['x-nvm-query-signature'] as string

        if (!planId || !subscriberAddress || !signature) {
          return res.status(400).json({ 
            error: 'Missing required payment parameters' 
          })
        }

        const isValid = await payments.isValidRequest(
          planId,
          agentId,
          subscriberAddress,
          signature
        )

        if (!isValid) {
          const paymentCard = await payments.getAgentPaymentCard(agentId)
          return res.status(402).json({
            error: 'Payment required',
            paymentCard
          })
        }

        // Attach payment info to request
        req.nevermined = { planId, agentId, subscriberAddress }
        next()

      } catch (error) {
        console.error('Auth middleware error:', error)
        res.status(500).json({ error: 'Authentication failed' })
      }
    }
  }
}
```

### Use Middleware

```typescript
const app = express()
const payments = Payments.getInstance({
  nvmApiKey: process.env.NVM_API_KEY,
  environment: 'production'
})

const auth = createNeverminedAuth(payments)
const agentId = process.env.AGENT_ID

// Apply to all protected routes
app.use('/api/*', auth(agentId))

// Or apply to specific routes
app.post('/api/query', auth(agentId), async (req, res) => {
  // Access payment info from req.nevermined
  const { planId } = req.nevermined
  
  // Process request...
  const result = await processQuery(req.body)
  
  // Redeem credits
  await payments.redeemCredits(planId, 1n, { query: req.body })
  
  res.json(result)
})
```

### Advanced Middleware Features

```typescript
export function createAdvancedAuth(payments: Payments, options?: {
  checkBalance?: boolean
  minCredits?: bigint
  rateLimitPerMinute?: number
}) {
  const requestCounts = new Map<string, number[]>()

  return (agentId: string) => {
    return async (req: NeverminedRequest, res: Response, next: NextFunction) => {
      try {
        // Basic validation
        const isValid = await payments.isValidRequest(
          req.body.planId,
          agentId,
          req.body.subscriberAddress,
          req.headers['x-nvm-query-signature'] as string
        )

        if (!isValid) {
          const paymentCard = await payments.getAgentPaymentCard(agentId)
          return res.status(402).json({ error: 'Payment required', paymentCard })
        }

        // Check balance if requested
        if (options?.checkBalance) {
          const balance = await payments.getPlanBalance(
            req.body.planId,
            req.body.subscriberAddress
          )

          if (balance.credits < (options.minCredits || 1n)) {
            return res.status(402).json({
              error: 'Insufficient credits',
              required: options.minCredits?.toString() || '1',
              available: balance.credits.toString()
            })
          }

          res.setHeader('X-Credits-Remaining', balance.credits.toString())
        }

        // Rate limiting per subscriber
        if (options?.rateLimitPerMinute) {
          const now = Date.now()
          const minute = 60 * 1000
          const key = req.body.subscriberAddress
          
          const requests = requestCounts.get(key) || []
          const recentRequests = requests.filter(t => now - t < minute)
          
          if (recentRequests.length >= options.rateLimitPerMinute) {
            return res.status(429).json({
              error: 'Rate limit exceeded',
              retryAfter: minute - (now - recentRequests[0])
            })
          }
          
          recentRequests.push(now)
          requestCounts.set(key, recentRequests)
        }

        req.nevermined = {
          planId: req.body.planId,
          agentId,
          subscriberAddress: req.body.subscriberAddress
        }

        next()

      } catch (error) {
        console.error('Auth error:', error)
        res.status(500).json({ error: 'Authentication failed' })
      }
    }
  }
}

// Usage
const advancedAuth = createAdvancedAuth(payments, {
  checkBalance: true,
  minCredits: 5n,
  rateLimitPerMinute: 60
})

app.post('/api/advanced-query', advancedAuth(agentId), handler)
```

## Proxy Integration

For existing services that can't be modified, use the Nevermined Proxy.

### How It Works

<Steps>
  <Step title="Register Your Service">
    Register your existing endpoints with Nevermined
  </Step>
  
  <Step title="Proxy Handles Payments">
    All payment validation happens at the proxy layer
  </Step>
  
  <Step title="No Code Changes">
    Your service continues to work as before
  </Step>
</Steps>

### Setup Process

```typescript
async function setupProxyIntegration() {
  const payments = Payments.getInstance({
    nvmApiKey: process.env.NVM_API_KEY,
    environment: 'production'
  })

  // Register your existing service
  const metadata = {
    name: 'Legacy AI Service',
    tags: ['ai', 'legacy', 'proxy'],
    dateCreated: new Date(),
    description: 'Existing AI service with payment layer'
  }

  const api = {
    endpoints: [
      // Your actual service endpoints
      { POST: 'https://legacy-api.example.com/process' },
      { GET: 'https://legacy-api.example.com/status' }
    ],
    openEndpoints: [
      // Public endpoints (no payment required)
      'https://legacy-api.example.com/health'
    ]
  }

  const price = getERC20PriceConfig(15_000_000n, USDC_ADDRESS, builderAddress)
  const credits = getFixedCreditsConfig(100n, 1n)

  const { agentId, planId } = await payments.registerAgentAndPlan(
    metadata,
    api,
    price,
    credits
  )

  console.log(`
    Proxy Integration Complete!
    
    Your service is now accessible at:
    https://proxy.nevermined.app/agent/${agentId}
    
    The proxy handles:
    - Payment validation
    - Credit redemption  
    - Access control
    - Usage tracking
  `)
}
```

### Client Usage

Subscribers access your proxied service:

```typescript
// For subscribers
async function useProxiedService() {
  const payments = Payments.getInstance({
    nvmApiKey: process.env.NVM_API_KEY,
    environment: 'production'
  })

  // Purchase plan
  await payments.orderPlan(planId)

  // Get access credentials
  const options = await payments.getAgentHTTPOptions(planId, agentId)

  // Make requests through proxy
  const response = await fetch(options.neverminedProxyUri, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${options.accessToken}`
    },
    body: JSON.stringify({
      // Your original API payload
      data: 'process this'
    })
  })

  const result = await response.json()
  console.log(result)
}
```

## Error Handling

Implement comprehensive error handling for all integration patterns:

```typescript
import { PaymentsError } from '@nevermined-io/payments'

// Express error handler
app.use((error: Error, req: Request, res: Response, next: NextFunction) => {
  if (error instanceof PaymentsError) {
    const statusMap = {
      'INVALID_API_KEY': 401,
      'INSUFFICIENT_BALANCE': 402,
      'INVALID_PLAN_CONFIG': 400,
      'NETWORK_ERROR': 503,
      'VALIDATION_ERROR': 400
    }

    const status = statusMap[error.code] || 500
    
    return res.status(status).json({
      error: error.message,
      code: error.code,
      details: error.details
    })
  }

  // Handle other errors
  console.error('Unexpected error:', error)
  res.status(500).json({ 
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? error.message : undefined
  })
})
```

## Testing Your Integration

### Unit Tests

```typescript
import { Payments } from '@nevermined-io/payments'

describe('Payment Integration', () => {
  let payments: Payments
  
  beforeEach(() => {
    payments = Payments.getInstance({
      nvmApiKey: process.env.NVM_TEST_API_KEY,
      environment: 'testing'
    })
  })

  test('should validate authorized requests', async () => {
    const isValid = await payments.isValidRequest(
      testPlanId,
      testAgentId,
      testSubscriber,
      validSignature
    )
    
    expect(isValid).toBe(true)
  })

  test('should reject unauthorized requests', async () => {
    const isValid = await payments.isValidRequest(
      testPlanId,
      testAgentId,
      'wrong-address',
      'invalid-signature'
    )
    
    expect(isValid).toBe(false)
  })
})
```

### Integration Tests

```typescript
import request from 'supertest'
import { app } from './app'

describe('API Integration', () => {
  test('should return 402 without payment', async () => {
    const response = await request(app)
      .post('/api/query')
      .send({ prompt: 'test' })
    
    expect(response.status).toBe(402)
    expect(response.body).toHaveProperty('paymentCard')
  })

  test('should process request with valid payment', async () => {
    const response = await request(app)
      .post('/api/query')
      .set('x-nvm-query-signature', validSignature)
      .send({
        planId: testPlanId,
        agentId: testAgentId,
        subscriberAddress: testSubscriber,
        prompt: 'test query'
      })
    
    expect(response.status).toBe(200)
    expect(response.body).toHaveProperty('result')
    expect(response.body.usage).toHaveProperty('creditsRemaining')
  })
})
```

## Production Checklist

Before going live:

- [ ] Environment variables configured
- [ ] Error handling implemented
- [ ] Rate limiting in place
- [ ] Logging and monitoring set up
- [ ] Security headers configured
- [ ] SSL/TLS enabled
- [ ] Health check endpoint working
- [ ] Payment flow tested end-to-end
- [ ] Documentation updated

## Next Steps

<CardGroup cols={2}>
  <Card title="Best Practices" icon="check" href="/introduction/best-practices">
    Security and performance recommendations
  </Card>
  <Card title="Go Live" icon="rocket" href="/introduction/go-live-checklist">
    Deploy your integrated service
  </Card>
  <Card title="Examples" icon="code" href="/introduction/example-apps">
    See complete implementations
  </Card>
  <Card title="Troubleshooting" icon="wrench" href="/introduction/troubleshooting">
    Common issues and solutions
  </Card>
</CardGroup>