---
title: "Error Handling"
description: "Learn how to handle errors and build robust applications with Nevermined Payments."
icon: "bug"
---

Robust error handling is critical for building reliable AI services. This guide covers common error scenarios, how to interpret them, and patterns for handling them gracefully in your application.

## Common Error Scenarios

The Nevermined SDK uses a custom `PaymentsError` class that includes a `code` property to help you identify the type of error. Here's how to handle common scenarios.

### Using a `try...catch` Block

```typescript
import { PaymentsError } from '@nevermined-io/payments';

try {
  const result = await payments.registerAgentAndPlan(metadata, api, price, credits);
} catch (error) {
  if (error instanceof PaymentsError) {
    // Handle specific Nevermined errors
    switch (error.code) {
      case 'INVALID_API_KEY':
        console.error('Authentication failed: Please check your API key.');
        break;
      case 'INSUFFICIENT_BALANCE':
        console.error('The transaction failed due to insufficient funds.');
        break;
      case 'INVALID_PLAN_CONFIG':
        console.error(`Plan configuration is invalid: ${error.message}`);
        break;
      case 'NETWORK_ERROR':
        console.error('A network error occurred. Please try again later.');
        break;
      default:
        console.error(`An unknown payments error occurred: ${error.message}`);
    }
  } else {
    // Handle unexpected errors
    console.error('An unexpected error occurred:', error);
  }
}
```

### Validation and 402 Errors

When a subscriber's request is invalid (e.g., invalid signature, insufficient credits), it's crucial to return a `402 Payment Required` status. Always fail closed for security.

```typescript
const isValid = await payments.isValidRequest(planId, agentId, subscriber, signature)
  .catch(error => {
    console.error('Validation check failed:', error);
    return false; // Fail closed
  });

if (!isValid) {
  // Always provide the payment card to help the user take action
  const paymentCard = await payments.getAgentPaymentCard(agentId);
  return response.status(402).json({
    error: 'Payment required to access this service.',
    paymentCard
  });
}
```

## Retry Logic for Transient Errors

Some operations, like redeeming credits, might fail due to temporary network issues. Implementing a retry mechanism with exponential backoff can make your application more resilient.

```typescript
async function withRetry<T>(fn: () => Promise<T>, maxRetries = 3): Promise<T> {
  let lastError: Error | undefined;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      if (attempt === maxRetries) {
        break; // Exit loop to throw the last error
      }
      
      // Calculate delay with exponential backoff and jitter
      const delay = Math.pow(2, attempt - 1) * 1000 + Math.random() * 250;
      console.log(`Attempt ${attempt} failed. Retrying in ${delay.toFixed(0)}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  throw lastError;
}

// How to use it:
try {
  const result = await withRetry(() => 
    payments.redeemCredits(planId, credits, proof)
  );
  console.log('Credits redeemed successfully.');
} catch (error) {
  console.error('Failed to redeem credits after multiple retries:', error);
  // Add to a queue for later processing or alert an admin
}
```

## Centralized Error Handling in Express.js

You can create a centralized error-handling middleware in Express to catch and format errors from the Nevermined SDK consistently.

```typescript
import { PaymentsError } from '@nevermined-io/payments';
import { Request, Response, NextFunction } from 'express';

export function neverminedErrorHandler(err: Error, req: Request, res: Response, next: NextFunction) {
  if (err instanceof PaymentsError) {
    const statusMap: { [code: string]: number } = {
      'INVALID_API_KEY': 401,
      'INSUFFICIENT_BALANCE': 402,
      'FORBIDDEN': 403,
      'NOT_FOUND': 404,
      'INVALID_PLAN_CONFIG': 400,
      'NETWORK_ERROR': 503, // Service Unavailable
      'VALIDATION_ERROR': 400,
    };

    const statusCode = statusMap[err.code] || 500;

    return res.status(statusCode).json({
      error: {
        code: err.code,
        message: err.message,
      }
    });
  }
  
  // If it's not a known error, pass it on
  next(err);
}

// Add it as the last middleware in your app setup
app.use(neverminedErrorHandler);
```

## Next Steps

- [Test error scenarios](/introduction/development#testing-your-agent)
- [Monitor production errors](/introduction/go-live-checklist#monitoring--analytics)
- [Get help with errors](https://discord.gg/nevermined)